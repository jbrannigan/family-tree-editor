{"ast":null,"code":"// utils/parseTree.js\n// Parse tab-indented text into an array of root nodes.\n// - Tabs are the source of truth for indentation.\n// - Optionally normalize leading groups of 4 spaces into a single tab.\n// - Generates stable-ish ids for React keys and focus behavior.\n\nexport function parseTree(text, {\n  normalizeSpaces = true\n} = {}) {\n  const src = String(text || \"\");\n  const linesRaw = src.split(\"\\n\");\n  const normalizeIndent = line => {\n    var _line$match$, _line$match;\n    if (!normalizeSpaces) return line;\n    const m = (_line$match$ = (_line$match = line.match(/^[ \\t]*/)) === null || _line$match === void 0 ? void 0 : _line$match[0]) !== null && _line$match$ !== void 0 ? _line$match$ : \"\";\n    const tabs = m.replace(/ {4}/g, \"\\t\").replace(/ +(?=\\t)/g, \"\");\n    return tabs + line.slice(m.length);\n  };\n  const lines = linesRaw.map(l => normalizeIndent(l)).filter(l => l.trim() !== \"\");\n  const roots = [];\n  const stack = []; // { level, node }\n\n  let idSeq = 0;\n  const makeNode = name => ({\n    id: `n-${idSeq++}`,\n    name,\n    children: []\n  });\n  for (const line of lines) {\n    const m = line.match(/^(\\t*)(.*)$/);\n    const level = ((m === null || m === void 0 ? void 0 : m[1]) || \"\").length;\n    const name = ((m === null || m === void 0 ? void 0 : m[2]) || \"\").trim();\n    const node = makeNode(name);\n    while (stack.length && stack[stack.length - 1].level >= level) stack.pop();\n    if (stack.length === 0) {\n      roots.push(node);\n      stack.push({\n        level,\n        node\n      });\n      continue;\n    }\n    const parent = stack[stack.length - 1].node;\n    parent.children.push(node);\n    stack.push({\n      level,\n      node\n    });\n  }\n  return roots;\n}","map":{"version":3,"names":["parseTree","text","normalizeSpaces","src","String","linesRaw","split","normalizeIndent","line","_line$match$","_line$match","m","match","tabs","replace","slice","length","lines","map","l","filter","trim","roots","stack","idSeq","makeNode","name","id","children","level","node","pop","push","parent"],"sources":["/home/jbrannigan/src/familytree/src/utils/parseTree.js"],"sourcesContent":["// utils/parseTree.js\n// Parse tab-indented text into an array of root nodes.\n// - Tabs are the source of truth for indentation.\n// - Optionally normalize leading groups of 4 spaces into a single tab.\n// - Generates stable-ish ids for React keys and focus behavior.\n\nexport function parseTree(text, { normalizeSpaces = true } = {}) {\n  const src = String(text || \"\");\n  const linesRaw = src.split(\"\\n\");\n\n  const normalizeIndent = (line) => {\n    if (!normalizeSpaces) return line;\n    const m = line.match(/^[ \\t]*/)?.[0] ?? \"\";\n    const tabs = m.replace(/ {4}/g, \"\\t\").replace(/ +(?=\\t)/g, \"\");\n    return tabs + line.slice(m.length);\n  };\n\n  const lines = linesRaw\n    .map((l) => normalizeIndent(l))\n    .filter((l) => l.trim() !== \"\");\n\n  const roots = [];\n  const stack = []; // { level, node }\n\n  let idSeq = 0;\n  const makeNode = (name) => ({ id: `n-${idSeq++}`, name, children: [] });\n\n  for (const line of lines) {\n    const m = line.match(/^(\\t*)(.*)$/);\n    const level = (m?.[1] || \"\").length;\n    const name = (m?.[2] || \"\").trim();\n    const node = makeNode(name);\n\n    while (stack.length && stack[stack.length - 1].level >= level) stack.pop();\n\n    if (stack.length === 0) {\n      roots.push(node);\n      stack.push({ level, node });\n      continue;\n    }\n    const parent = stack[stack.length - 1].node;\n    parent.children.push(node);\n    stack.push({ level, node });\n  }\n\n  return roots;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASA,SAASA,CAACC,IAAI,EAAE;EAAEC,eAAe,GAAG;AAAK,CAAC,GAAG,CAAC,CAAC,EAAE;EAC/D,MAAMC,GAAG,GAAGC,MAAM,CAACH,IAAI,IAAI,EAAE,CAAC;EAC9B,MAAMI,QAAQ,GAAGF,GAAG,CAACG,KAAK,CAAC,IAAI,CAAC;EAEhC,MAAMC,eAAe,GAAIC,IAAI,IAAK;IAAA,IAAAC,YAAA,EAAAC,WAAA;IAChC,IAAI,CAACR,eAAe,EAAE,OAAOM,IAAI;IACjC,MAAMG,CAAC,IAAAF,YAAA,IAAAC,WAAA,GAAGF,IAAI,CAACI,KAAK,CAAC,SAAS,CAAC,cAAAF,WAAA,uBAArBA,WAAA,CAAwB,CAAC,CAAC,cAAAD,YAAA,cAAAA,YAAA,GAAI,EAAE;IAC1C,MAAMI,IAAI,GAAGF,CAAC,CAACG,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAACA,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC;IAC9D,OAAOD,IAAI,GAAGL,IAAI,CAACO,KAAK,CAACJ,CAAC,CAACK,MAAM,CAAC;EACpC,CAAC;EAED,MAAMC,KAAK,GAAGZ,QAAQ,CACnBa,GAAG,CAAEC,CAAC,IAAKZ,eAAe,CAACY,CAAC,CAAC,CAAC,CAC9BC,MAAM,CAAED,CAAC,IAAKA,CAAC,CAACE,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC;EAEjC,MAAMC,KAAK,GAAG,EAAE;EAChB,MAAMC,KAAK,GAAG,EAAE,CAAC,CAAC;;EAElB,IAAIC,KAAK,GAAG,CAAC;EACb,MAAMC,QAAQ,GAAIC,IAAI,KAAM;IAAEC,EAAE,EAAE,KAAKH,KAAK,EAAE,EAAE;IAAEE,IAAI;IAAEE,QAAQ,EAAE;EAAG,CAAC,CAAC;EAEvE,KAAK,MAAMpB,IAAI,IAAIS,KAAK,EAAE;IACxB,MAAMN,CAAC,GAAGH,IAAI,CAACI,KAAK,CAAC,aAAa,CAAC;IACnC,MAAMiB,KAAK,GAAG,CAAC,CAAAlB,CAAC,aAADA,CAAC,uBAADA,CAAC,CAAG,CAAC,CAAC,KAAI,EAAE,EAAEK,MAAM;IACnC,MAAMU,IAAI,GAAG,CAAC,CAAAf,CAAC,aAADA,CAAC,uBAADA,CAAC,CAAG,CAAC,CAAC,KAAI,EAAE,EAAEU,IAAI,CAAC,CAAC;IAClC,MAAMS,IAAI,GAAGL,QAAQ,CAACC,IAAI,CAAC;IAE3B,OAAOH,KAAK,CAACP,MAAM,IAAIO,KAAK,CAACA,KAAK,CAACP,MAAM,GAAG,CAAC,CAAC,CAACa,KAAK,IAAIA,KAAK,EAAEN,KAAK,CAACQ,GAAG,CAAC,CAAC;IAE1E,IAAIR,KAAK,CAACP,MAAM,KAAK,CAAC,EAAE;MACtBM,KAAK,CAACU,IAAI,CAACF,IAAI,CAAC;MAChBP,KAAK,CAACS,IAAI,CAAC;QAAEH,KAAK;QAAEC;MAAK,CAAC,CAAC;MAC3B;IACF;IACA,MAAMG,MAAM,GAAGV,KAAK,CAACA,KAAK,CAACP,MAAM,GAAG,CAAC,CAAC,CAACc,IAAI;IAC3CG,MAAM,CAACL,QAAQ,CAACI,IAAI,CAACF,IAAI,CAAC;IAC1BP,KAAK,CAACS,IAAI,CAAC;MAAEH,KAAK;MAAEC;IAAK,CAAC,CAAC;EAC7B;EAEA,OAAOR,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}