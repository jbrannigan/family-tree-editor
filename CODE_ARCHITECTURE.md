# Family Tree Editor - Code Architecture Documentation

This document explains how the Family Tree Editor application works, breaking down the components, data flow, and key concepts to help you understand the codebase that was primarily generated by ChatGPT.

## 🏗️ Project Overview

The Family Tree Editor is a React-based web application that allows users to:

- Edit family trees using a simple text format called "TreeDown"
- View trees in an interactive, collapsible tree view
- Visualize trees as SVG diagrams
- Export trees in multiple formats (HTML, JSON, SVG, TXT)
- Focus on specific branches for detailed editing

## 📁 Project Structure

```
src/
├── App.js              # Main application component & state management
├── TreeEditor.js       # Text editor with syntax features
├── TreeView.js         # Interactive tree view component
├── GraphView.js        # SVG diagram generator
├── UploadButton.js     # File upload handling
├── utils/
│   ├── parseTree.js    # TreeDown text → tree data parser
│   ├── treeToText.js   # Tree data → TreeDown text converter
│   ├── buildPedigree.js # Generates ancestor-only pedigree trees
│   └── generateHTML.js # Tree data → standalone HTML export
├── tests/
│   └── parseTree.test.js
└── e2e/                # End-to-end tests
    ├── html-export.spec.js
    └── treeview-a11y.spec.js
```

## 🔄 Data Flow & State Management

### Main Data Flow

```
TreeDown Text → parseTree() → Tree Object → Components → User Interface
     ↑                                          ↓
     └─────────── User Edits ←─────────────────────┘
```

### State Management (App.js)

The main application state is managed in `App.js` using React hooks:

- **`treeText`**: Raw TreeDown text input from user
- **`fullTree`**: Parsed tree structure (computed from `treeText`)
- **`focusedNode`**: Currently focused node for branch isolation
- **`displayedTree`**: What's shown in views (either `fullTree` or focused branch)
- **`exportFocused`**: Boolean controlling export behavior
- **`showPedigree`**: When true, shows ancestors-only pedigree view
- **`activeTab`**: Currently active tab ('editor', 'tree', or 'graph')
- **`rememberUpload`**: Boolean for localStorage persistence preference

### Key State Effects

- Changes to `treeText` automatically trigger parsing via `useMemo`
- Parse errors are caught and logged, showing empty tree as fallback
- LocalStorage persistence keeps user data between sessions

## 🧩 Core Components

### 1. App.js - Application Controller

**Purpose**: Main orchestrator that manages all state and coordinates components

**Key Responsibilities**:

- State management for tree text, focus, and export options
- File operations (open, save, export)
- LocalStorage persistence
- Coordinate data flow between components

**Key Functions**:

- `parseTree()` - Converts text to tree structure using memoization
- `handleTextChange()` - Updates tree text state
- `handleFileLoaded()` - Processes uploaded files
- Export handlers (`handleDownloadHTML`, `handleDownloadSVG`, etc.)

### 2. TreeEditor.js - Text Editor Interface

**Purpose**: Provides a code-editor-like interface for editing TreeDown text

**Key Features**:

- Line numbers with current line highlighting
- Tab/Shift+Tab indentation support (essential for TreeDown hierarchy)
- Soft wrap toggle for long lines
- "Normalize indentation" button (converts 4 spaces → tabs)
- Synchronized scrolling between gutter and textarea

**How Indentation Works**:

- Tab key adds tabs to selected lines
- Shift+Tab removes leading tabs/spaces
- Maintains selection across indentation changes

### 3. TreeView.js - Interactive Tree Display

**Purpose**: Shows the tree as an accessible, keyboard-navigable interface

**Key Features**:

- Fully ARIA-compliant tree widget (`role="tree"`, `role="treeitem"`, `aria-expanded`, `aria-level`, `aria-posinset`, `aria-setsize`)
- Keyboard navigation (arrow keys, Enter, Space, Escape, Home, End)
- Expand/collapse functionality with toolbar buttons
- Focus nodes with 🔍 buttons
- Smart filtering with expand/collapse memory
- Roving tabindex for efficient keyboard navigation
- Screen reader announcements via `aria-live` regions

**Navigation Behavior**:

- ↑/↓: Move between visible items
- ←/→: Collapse/expand or move to parent/child
- Enter: Focus on node (isolate branch)
- Space: Toggle expand/collapse
- Escape: Unfocus (return to full tree)

**State Management**:

- `expanded`: Set of node IDs that are expanded
- `activeId`: Currently highlighted node for keyboard navigation
- Filtering temporarily modifies expansion state but remembers user preferences

### 4. GraphView.js - SVG Diagram Generator

**Purpose**: Creates visual tree diagrams using SVG

**Layout Algorithm**:

1. **Text Wrapping**: Breaks long names into multiple lines
2. **Size Calculation**: Measures box dimensions based on text content
3. **Subtree Layout**: Recursively calculates space needed for each subtree
4. **Positioning**: Centers parents over children, places siblings left-to-right
5. **Rendering**: Draws boxes, text, and connecting lines

**Key Functions**:

- `wrapText()` - Breaks text at word boundaries or character limits
- `measureNodeBox()` - Calculates box size from wrapped text
- `computeSizes()` - Recursively determines subtree dimensions
- `assignPositions()` - Places nodes using centering algorithm
- `renderNode()` - Creates SVG elements for nodes and connections

## 🛠️ Utility Functions

### parseTree.js - TreeDown Parser

**Purpose**: Converts indented text into tree data structure

### treeToText.js - TreeDown Generator

**Purpose**: Converts tree data structure back to TreeDown text format

**Use cases**:

- Exporting focused branches as text
- Round-trip conversion (parse → modify → export)

### buildPedigree.js - Pedigree Generator

**Purpose**: Generates ancestor-only pedigree trees from a focus node

**Algorithm**:

1. Start at focus node
2. Walk up parent references to collect all ancestors
3. Build new tree containing only direct lineage
4. Used for "Show pedigree when focused" feature

**TreeDown Format Rules**:

- Indentation defines hierarchy (tabs or 4-space groups)
- Each line becomes a tree node
- Empty/whitespace lines are ignored
- Missing names become "(unnamed)"

**Algorithm**:

1. Normalize text (handle BOM, line endings)
2. For each line:
   - Measure indentation level
   - Extract name from remaining text
   - Create node with unique ID
   - Place in tree based on indentation stack

**Example**:

```
John & Mary
    Alice
        Bob
    Charlie
```

Becomes:

```json
[
  {
    "id": "n-0",
    "name": "John & Mary",
    "children": [
      {
        "id": "n-1",
        "name": "Alice",
        "children": [{ "id": "n-2", "name": "Bob", "children": [] }]
      },
      { "id": "n-3", "name": "Charlie", "children": [] }
    ]
  }
]
```

### generateHTML.js - Static Export Generator

**Purpose**: Creates standalone HTML files with embedded tree viewer

**Features**:

- Self-contained: includes CSS, JavaScript, and data
- Interactive: expand/collapse, focus/unfocus functionality
- No external dependencies
- Identical functionality to main app's TreeView

**Architecture**:

- Embeds tree data as JSON in script tag
- Vanilla JavaScript for interactivity
- CSS-only styling (no external frameworks)
- Progressive enhancement approach

## 🔑 Key Concepts

### Focus System

**What it does**: Allows users to isolate and work with specific branches

**How it works**:

1. User clicks 🔍 button or presses Enter on a node
2. `focusedNode` state is set to that node
3. `displayedTree` becomes `[focusedNode]` instead of `fullTree`
4. All views (TreeView, GraphView) show only the focused branch
5. Export options can target focused view vs. full tree

**Use cases**:

- Edit large trees by focusing on specific families
- Export branches for sharing/collaboration
- Reduce visual complexity when working with deep trees

### Export System

**Formats supported**:

- **SVG**: Vector diagram from GraphView component
- **HTML**: Standalone interactive viewer
- **JSON**: Structured data for programmatic use
- **TXT**: Original TreeDown text format

**Export modes**:

- **Full tree**: Export everything
- **Focused view**: Export only currently focused branch (when "Export focused view" is checked)

### Indentation Handling

The editor supports flexible indentation to accommodate different user preferences:

- **Tabs**: Each tab = 1 hierarchy level
- **Spaces**: Every 4 spaces = 1 hierarchy level
- **Mixed**: Tabs and spaces can be combined
- **Normalization**: "Normalize indentation" converts spaces to tabs

## 🔍 Testing Strategy

### Unit Tests (Vitest)

- Focus on `parseTree()` function with various input scenarios
- Test indentation edge cases, malformed input, empty content

### End-to-End Tests (Playwright)

- HTML export functionality verification
- Tree view accessibility compliance
- Keyboard navigation behavior
- Export/import workflows

## 🚀 Development Workflow

### Running the Application

```bash
npm start          # Development server
npm run build      # Production build
npm test           # Run unit tests
npm run test:e2e   # Run E2E tests
```

### Code Quality Tools

- **ESLint**: Code linting with React-specific rules
- **Prettier**: Code formatting
- **Husky**: Pre-commit hooks for quality gates
- **Dependency Cruiser**: Architecture visualization

### Architecture Analysis

The project includes several tools for understanding code structure:

- `npm run depgraph` - Generate dependency graph
- `npm run callgraph` - Generate call graphs for components
- Generated visualizations help understand component relationships

## 🎯 Key Design Decisions

1. **Text-First Approach**: TreeDown format prioritizes human readability and git-friendliness
2. **React Hooks**: Modern React patterns for state management without external libraries
3. **Accessibility First**: Full ARIA compliance, comprehensive keyboard navigation, descriptive labels for all interactive elements
4. **Tabbed Interface**: Single-view layout reduces cognitive load and works better on narrow screens
5. **Progressive Enhancement**: Core functionality works without JavaScript (in exports)
6. **No External UI Framework**: Custom CSS keeps bundle small and styling consistent
7. **Memoization**: Performance optimization for expensive parsing operations
8. **Local Storage**: Automatic persistence improves user experience

## 🤔 Common Questions

**Q: Why not use a state management library like Redux?**
A: The app's state is relatively simple and well-contained in the root component. React's built-in hooks provide sufficient functionality.

**Q: How does the focus system work with exports?**
A: When "Export focused view" is checked, exports use `displayedTree` (focused branch) instead of `fullTree`. This allows sharing specific family branches.

**Q: Why the custom indentation parser instead of existing libraries?**
A: TreeDown's specific rules (tabs + 4-space groups, empty line handling) required custom logic. The parser is also kept simple for maintainability.

**Q: How are IDs generated and why are they important?**
A: IDs are auto-generated incrementally (`n-0`, `n-1`, etc.) and provide stable references for focus, expansion state, and tree navigation.

**Q: Why use tabs instead of a multi-pane layout?**
A: Tabs reduce visual complexity, work better on mobile/narrow screens, and provide a clearer mental model. The previous three-pane layout was overwhelming for some users.

**Q: What accessibility features are implemented?**
A: Comprehensive ARIA markup, keyboard navigation (arrows/Enter/Space/Escape), descriptive labels for all controls, screen reader announcements, roving tabindex, and visible focus indicators throughout.

This architecture emphasizes simplicity, accessibility, and maintainability while providing powerful tree editing and visualization capabilities.
